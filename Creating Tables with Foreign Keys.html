<!DOCTYPE html>

<html lang="en" xmlns="http://www.w3.org/1999/xhtml">
<head>
    <meta charset="utf-8" />
    <title></title>
</head>
<body>

    <h1>
        Creating tables with foreign keys</h1>
    <p>
        Mono.Data.Sqlite.Orm can create any type of foreign keys: from the very simple 
        to almost any type that can be create with a SQL command, but all without 
        writing a single line of T-SQL.</p>
    <p>
        In these examples, You will see just how easy it can be.</p>
    <h2>
        A single reference:</h2>
    <p>
        Suppose we have a tiny program that we use to organize our personal book 
        collection:</p>
    <p>
        This application will allow us to create both books and categories:</p>
    <ul>
        <li>A book can only go under one category.</li>
        <li>A category may have many books.</li>
    </ul>
    <p>
        We also want a very simple model that only records the necessary data:</p>
    <ul>
        <li>A book has an Id (unique to our collection), a Title and a Category.</li>
        <li>A category has an Id (for reference by a book) and a Name</li>
    </ul>
    <p>
        We would like the database to keep track of our Ids so that we don&#39;t have to 
        write any code to make sure that the Ids are unique.
    </p>
    <p>
        How do we do all of this? We can create a class with members that are decorated 
        by Attributes.</p>
    <pre>
 // Defines the structure of the Category table
public class Category
{
    [PrimaryKey]
    [AutoIncrement]
    public int Id { get; set; }

    public string Name { get; set; }
}</pre>
    <pre>
// Defines the structure of the Book table
public class Book 
{
    [PrimaryKey]
    [AutoIncrement] 
    public int Id { get; set; }

    public string Title { get; set; } 

    [ForeignKey(typeof(Category), &quot;Id&quot;, Name = &quot;FK_Book_Category&quot;)] 
    public int CategoryId { get; set; }
}</pre>
    <p>Now we can create the tables in the database:</p>
    <pre>
public void CreateDatabase()
{
    using (var db = new SqliteSession(connectionString))
    {
        db.CreateTable&lt;Category&gt;();
        db.CreateTable&lt;Book&gt;();
    }
}</pre>
    <p>
        This creates and executes the following SQL on the database:</p>
    <pre>
-- Create the catecories table
CREATE TABLE [Category] (
    [Id] integer PRIMARY KEY AUTOINCREMENT NOT NULL,
    [Name] text 
);</pre>
    <pre>
-- Create the books table with the foreign key
CREATE TABLE [Book] (
    [Id] integer PRIMARY KEY AUTOINCREMENT NOT NULL,
    [Title] text,
    [CategoryId] integer NOT NULL, 

    CONSTRAINT FK_Book_Category  -- FK name
        FOREIGN KEY (CategoryId) -- column in this table 
        REFERENCES Category (Id) -- column in the other table 
);</pre>
    <p>
        The foreign key attribute has several properties that we can set to determine 
        how the foreign key will be created:</p>
    <ul>
        
        <li><strong>Name</strong> - this allows you to provide a custom name for this 
            constraint. If none is specified, SQLite will create a random name.</li>
        <li><strong>ChildTable</strong> - this is the other table that is referenced in the 
            foreign key. It is required.</li>
        <li><strong>ChildKey</strong> - this is the column that is referenced in the other 
            table. It is required.</li>
        <li><strong>Order</strong> - this allows you to specify the position in which 
            to place the column reference if you have a multi-column foreign key.</li>
        <li><strong>OnDeleteAction</strong> - this allows you to specify the action to 
            take when the referenced record is deleted.</li>
        <li><strong>OnUpdateAction</strong> - this allows you to specify the action to take 
            when the referenced record is updated.</li>
        <li><strong>NullMatch</strong> - this allows you to specify the null matching.</li>
        <li><strong>Deferred</strong> - this allows you to specify the deffered value.</li>
    </ul>
    <p>
        Only two properties are required to they provide the information to create the 
        foreign key: ChildTable and ChildKey. These values are provided in the 
        constructor.</p>
    <h2>A composite foreign keys</h2>
    <p>
        Suppose for a moment that we are some great developers for a international bank. 
        This bank has &quot;Bank Accounts&quot; that they provide for clients to use to hold the 
        client&#39;s money. This bank provides different types of accounts: Smart accounts, 
        Savings accounts and Cheque accounts. Internally, they are exactly the same, but 
        they need to flood the client with &quot;types&quot; to make it look like the client is 
        benefiting. Accounts have transaction history which is a record of client 
        deposits, bank fees and, if the client is luck and rich, withdrawals. We are 
        going to be designing such a system.</p>
    <p>
        There are 3 entities here:</p>
    <ol>
        <li>Bank Accounts</li>
        <li>Account Types</li>
        <li>Account Transactions</li>
    </ol>

    <p>
        Account Types is a very simple entity: it only has a unique id, a name. 
        Now in our first prototype (because we are very poor architects) we use an enum.</p>
    <pre>public enum AccountType 
{
    Smart,
    Savings,
    Cheque
}</pre>
    <p>
        Now we need to make the bank account. This has a composite primary key: the 
        AccountId and the AccountType. We need to do this as there are going to be so 
        many accounts that we need to allow for more accounts than can be represented by 
        a single number. So we use a second number as well. Here is what we do:</p>
    <pre>public class BankAccount 
{
    [PrimaryKey] 
    public long AccountId { get; set; } 

    [PrimaryKey] 
    public AccountType AccountType { get; set; } 
        
    public string ClientId { get; set; } 
        
    public decimal Balance { get; set; } 
}</pre>
        <p>
            This will generate 
            some cool SQL, and as you can see, we have a composite primary key as well:</p>
    <pre>
CREATE TABLE [BankAccount] (
    [AccountId] bigint NOT NULL, 
    [AccountType] integer NOT NULL, 
    [ClientId] text, 
    [Balance] float NOT NULL, 

    PRIMARY KEY (AccountId, AccountType)
);</pre>
    <p>
        Now for the exciting stuff, the foreign keys and the transactions. This bank 
        doesn&#39;t care where the money comes in from or where the money goes out to. All 
        they need is which account and what amount:</p>
    <pre>public class AccountTransaction 
{
    [ForeignKey(typeof(BankAccount), &quot;AccountId&quot;, Name = &quot;FK_AccountTransaction&quot;)] 
    public long AccountId { get; set; } 
        
    [ForeignKey(typeof(BankAccount), &quot;AccountType&quot;, Name = &quot;FK_AccountTransaction&quot;)] 
    public AccountType AccountType { get; set; } 

    public decimal Amount { get; set; } 
}</pre>

    <p>
        In the above example, we specify a foreign key name so that the ORM knows that 
        we are referring to the same foreign key, and thus makes it a composite key. 
        This will generate some more SQL:</p>
    <pre>CREATE TABLE [AccountTransaction] (
    [AccountId] bigint NOT NULL, 
    [AccountType] integer NOT NULL,
    [Amount] float NOT NULL, 

    CONSTRAINT FK_AccountTransaction 
        FOREIGN KEY (AccountId, AccountType) 
        REFERENCES BankAccount (AccountId, AccountType) 
);</pre>
    <p>
        And as you can see, our database is ready to go.</p>

</body>
</html>